<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<title>Tiki Tour ‚Äî Smart Time Search</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

<style>
  :root{
    --bg:#fff; --card:#f8f8f8; --text:#111; --muted:#666;
    --accent:#ff8833; --shadow: 0 8px 24px rgba(10,10,10,0.08);
    --glass: rgba(255,255,255,0.6);
  }
  @media (prefers-color-scheme: dark) {
    :root{
      --bg: #081018; --card: rgba(12,18,24,0.7); --text:#e9f5ef; --muted:#9fb3a6;
      --accent:#ffb06b; --shadow: 0 10px 30px rgba(0,0,0,0.6);
    }
  }
  html,body{height:100%;margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial; background: linear-gradient(180deg, rgba(255,241,224,0.3), transparent 40%), var(--bg); color:var(--text); -webkit-font-smoothing:antialiased;}
  @media (prefers-color-scheme: light) { body{background: linear-gradient(180deg, #fff8f0, #f7fbf9 60%), var(--bg);} }

  /* splash */
  #splash { position:fixed; inset:0; z-index:9999; display:flex; align-items:center; justify-content:center; background: linear-gradient(135deg, rgba(3,91,70,0.95), rgba(19,53,57,0.95)); color:white; flex-direction:column; gap:18px; -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px); }
  .tiki { width:86px;height:86px;border-radius:18px;background:linear-gradient(180deg,#ffe1b9,#ffd59a);display:flex;align-items:center;justify-content:center;box-shadow:0 12px 40px rgba(0,0,0,0.35); transform: rotate(-6deg); }
  .tiki-emoji{font-size:46px;transform:translateY(6px);}
  .coconut { width:46px;height:46px;border-radius:50%;border:4px solid rgba(255,255,255,0.12);display:flex;align-items:center;justify-content:center; animation:coconutSpin 1500ms linear infinite; }
  @keyframes coconutSpin{from{transform:rotate(0deg);}to{transform:rotate(360deg);} }

  /* shell */
  #app { max-width:1000px;margin:12vh auto 48px;padding:12px;box-sizing:border-box;}
  .card { background:var(--card); border-radius:14px; box-shadow:var(--shadow); overflow:hidden; padding:0; -webkit-backdrop-filter: blur(6px); }
  #map { width:100%; height:64vh; min-height:420px; display:block; border-radius:12px 12px 0 0; }

  .controls { display:flex; gap:10px; padding:14px; align-items:center; flex-wrap:wrap;}
  .input { display:flex; gap:8px; align-items:center;}
  label.small { font-size:13px; color:var(--muted); margin-right:6px; }
  input[type="number"], select { width:120px; padding:10px 12px; border-radius:10px; border:1px solid rgba(0,0,0,0.06); background:transparent; color:var(--text); font-size:15px; outline:none;}
  @media (prefers-color-scheme: dark) { input[type="number"], select { border:1px solid rgba(255,255,255,0.04); } }

  .btn { padding:10px 14px; font-weight:700; border-radius:12px; border:none; cursor:pointer; font-size:15px; box-shadow:0 6px 18px rgba(0,0,0,0.12); background: linear-gradient(180deg,var(--accent), color-mix(in srgb, var(--accent) 85%, black 8%)); color:#062014; display:inline-flex; align-items:center; gap:8px; transition: transform 180ms ease, box-shadow 180ms ease; }
  .btn.ghost { background:transparent; color:var(--text); border:1px solid rgba(0,0,0,0.06); }
  .btn:active { transform: translateY(2px); box-shadow: 0 4px 12px rgba(0,0,0,0.12); }

  .statusRow { width:100%; padding:8px 14px 12px 14px; color:var(--muted); font-size:13px; display:flex; gap:10px; align-items:center; }
  .stats { padding:8px 14px 18px 14px; display:flex; gap:12px; align-items:center; flex-wrap:wrap;}
  .pill { background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02)); padding:8px 12px; border-radius:999px; font-weight:700; color:var(--text); }

  .mascot { position: fixed; right:14px; bottom:18vh; z-index:900; display:flex; align-items:center; gap:10px; pointer-events:none; }
  .monkey { font-size:38px; transform-origin:center; display:inline-block; animation:monkeyDance 1600ms ease-in-out infinite; filter: drop-shadow(0 8px 18px rgba(0,0,0,0.25)); }
  .mascot-bubble { background:var(--glass); padding:8px 10px; border-radius:999px; font-weight:700; color:var(--text); font-size:14px; box-shadow:0 6px 18px rgba(0,0,0,0.08); pointer-events:none; }
  @keyframes monkeyDance { 0%{transform:translateY(0) rotate(-6deg) scale(1);} 25%{transform:translateY(-6px) rotate(6deg) scale(1.06);} 50%{transform:translateY(0px) rotate(-4deg) scale(1);} 75%{transform:translateY(-4px) rotate(8deg) scale(1.03);} 100%{transform:translateY(0) rotate(-6deg) scale(1);} }

  .drop-pin { animation: dropPin 540ms cubic-bezier(.2,.9,.2,1) both; }
  @keyframes dropPin { 0%{transform:translateY(-200px) scale(0.8); opacity:0;} 60%{transform:translateY(16px) scale(1.05); opacity:1;} 100%{transform:translateY(0) scale(1);} }
  .hidden{display:none;}
  @media (max-width:520px) { .controls{padding:12px;gap:8px;} #map{height:65vh;min-height:360px;} .mascot{right:10px;bottom:22vh;} body{margin-bottom:48px;} }
</style>
</head>
<body>

<div id="splash" aria-hidden="false">
  <div class="tiki"><div class="tiki-emoji">üå∫</div></div>
  <div class="splash-title">
    <div style="display:flex;flex-direction:column;line-height:1">
      <div style="font-size:20px;font-weight:900">Tiki Tour</div>
      <div style="font-size:12px;opacity:0.95">Find a random road. Take a little adventure.</div>
    </div>
  </div>
  <div class="coconut center" style="margin-top:8px"><div style="font-size:20px">ü••</div></div>
</div>

<div id="app" class="card" style="max-width:880px;margin:auto">

  <div id="map"></div>

  <div class="controls">
    <div class="input">
      <label class="small">Mode</label>
      <select id="modeSelect" aria-label="Mode: By Distance or By Time">
        <option value="distance">By Distance</option>
        <option value="time">By Time</option>
      </select>
    </div>

    <div class="input">
      <label class="small" for="kmInput">Distance km (one-way)</label>
      <input id="kmInput" type="number" step="0.1" min="0.1" value="15" />
    </div>

    <div class="input">
      <label class="small" for="timeInput">Time min (total)</label>
      <input id="timeInput" type="number" step="1" min="5" value="20" />
    </div>

    <div class="input">
      <label class="small" for="tripType">Trip</label>
      <select id="tripType">
        <option value="oneway">One Way</option>
        <option value="return">Return Trip</option>
      </select>
    </div>

    <div class="input">
      <label class="small" for="mapApp">Open with</label>
      <select id="mapApp">
        <option value="apple">Apple Maps</option>
        <option value="google">Google Maps</option>
        <option value="waze">Waze</option>
      </select>
    </div>

    <button id="pickBtn" class="btn" title="Pick a random drivable road near you">üéØ Pick Random Road</button>
    <button id="openMapsBtn" class="btn ghost" disabled>üß≠ Open</button>
    <button id="clearBtn" class="btn ghost">üßπ Clear</button>

    <div id="status" style="margin-left:auto;color:var(--muted);font-size:14px">Waiting for location.</div>
  </div>

  <div class="statusRow">
    <div id="progress" style="flex:1;color:var(--muted);font-size:13px">Idle.</div>
    <div id="attempts" style="color:var(--muted);font-size:13px"></div>
  </div>

  <div class="stats">
    <div id="routeInfo" class="pill">No route selected</div>
    <div style="color:var(--muted);font-size:13px">Using highway speed 100 km/h first, then 60 km/h if needed. Tolerance ¬±10%.</div>
  </div>

</div>

<div class="mascot" aria-hidden="true">
  <div class="mascot-bubble">Ready for a Tiki hop?</div>
  <div class="monkey" id="monkeyEmoji">üêí</div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
/*
  Smart time-search version.
  Uses highway speed 100 km/h then normal roads 60 km/h fallback.
  Iteratively adjusts radius to home in on desired one-way time (¬±10%).
*/

const splash = document.getElementById('splash');
const statusEl = document.getElementById('status');
const progressEl = document.getElementById('progress');
const attemptsEl = document.getElementById('attempts');

const kmInput = document.getElementById('kmInput');
const timeInput = document.getElementById('timeInput');
const modeSelect = document.getElementById('modeSelect');
const tripTypeSelect = document.getElementById('tripType');
const mapAppSelect = document.getElementById('mapApp');

const pickBtn = document.getElementById('pickBtn');
const openMapsBtn = document.getElementById('openMapsBtn');
const clearBtn = document.getElementById('clearBtn');
const routeInfo = document.getElementById('routeInfo');
const monkey = document.getElementById('monkeyEmoji');

let userCoords = null, userMarker = null, destMarker = null, routeLayer = null, snappedDest = null, lastFoundRoute = null;

const HIGHWAY_SPEED = 100; // km/h (user-specified)
const NORMAL_SPEED = 60;   // km/h (user-specified)
const TOLERANCE = 0.10;    // ¬±10%
const MAX_TRIES = 40;

const map = L.map('map', { zoomControl:true }).setView([0,0], 2);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19, attribution:'¬© OpenStreetMap contributors'}).addTo(map);

function hideSplash(){ if(!splash) return; splash.style.opacity='0'; splash.style.transform='scale(0.98)'; setTimeout(()=> { if(splash) splash.remove(); }, 520); }
function setStatus(t){ statusEl.textContent = t || ''; }
function setProgress(t){ progressEl.textContent = t || ''; }
function setAttempts(t){ attemptsEl.textContent = t || ''; }

// initial location
function enableLocation(){
  if(!navigator.geolocation){ setStatus('Location not supported by browser.'); return; }
  setStatus('Locating you.');
  navigator.geolocation.getCurrentPosition(pos=>{
    userCoords = { lat: pos.coords.latitude, lon: pos.coords.longitude };
    setStatus('');
    if(userMarker) userMarker.remove();
    userMarker = L.marker([userCoords.lat, userCoords.lon], { title:'You' }).addTo(map);
    map.setView([userCoords.lat, userCoords.lon], 13);
    hideSplash();
  }, err => { console.error(err); setStatus('Allow location in browser and reload.'); }, { enableHighAccuracy:true, maximumAge:15000, timeout:12000 });
}
enableLocation();
setInterval(()=> {
  if(!document.hidden && navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(pos => {
      userCoords = { lat: pos.coords.latitude, lon: pos.coords.longitude };
      if(userMarker) userMarker.setLatLng([userCoords.lat, userCoords.lon]);
    }, ()=>{}, { enableHighAccuracy:true, maximumAge:20000 });
  }
}, 8000);

// UI mode toggling: disable irrelevant input
function updateModeUI(){
  if(modeSelect.value === 'distance'){ kmInput.disabled=false; kmInput.style.opacity='1'; timeInput.disabled=true; timeInput.style.opacity='0.6'; }
  else { kmInput.disabled=true; kmInput.style.opacity='0.6'; timeInput.disabled=false; timeInput.style.opacity='1'; }
}
modeSelect.addEventListener('change', updateModeUI);
updateModeUI();

// --- island check (rough) ---
const NORTH_ISLAND_MIN_LAT = -41.6;
function isSameIsland(latA, latB){
  const aNorth = latA > NORTH_ISLAND_MIN_LAT;
  const bNorth = latB > NORTH_ISLAND_MIN_LAT;
  return (aNorth && bNorth) || (!aNorth && !bNorth);
}

// --- geospatial helpers ---
function randomCoordinate(centerLat, centerLon, maxMeters){
  const R = 6371000;
  const r = Math.sqrt(Math.random()) * maxMeters;
  const bearing = Math.random() * Math.PI * 2;
  const lat1 = centerLat * Math.PI / 180;
  const lon1 = centerLon * Math.PI / 180;
  const lat2 = Math.asin(Math.sin(lat1) * Math.cos(r / R) + Math.cos(lat1) * Math.sin(r / R) * Math.cos(bearing));
  const lon2 = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(r / R) * Math.cos(lat1), Math.cos(r / R) - Math.sin(lat1) * Math.sin(lat2));
  return { lat: lat2 * 180 / Math.PI, lon: lon2 * 180 / Math.PI };
}

async function snapToRoad(lon, lat){
  try {
    const url = `https://router.project-osrm.org/nearest/v1/driving/${lon},${lat}?number=1`;
    const res = await fetch(url);
    if(!res.ok) return null;
    const j = await res.json();
    if(j && j.waypoints && j.waypoints.length){
      const wp = j.waypoints[0];
      return { lat: wp.location[1], lon: wp.location[0] };
    }
  } catch(e) { console.error('snap error',e); }
  return null;
}

async function getRoute(user, dest){
  try {
    const coords = `${user.lon},${user.lat};${dest.lon},${dest.lat}`;
    const url = `https://router.project-osrm.org/route/v1/driving/${coords}?overview=full&geometries=geojson&steps=false`;
    const res = await fetch(url);
    if(!res.ok) return null;
    const j = await res.json();
    if(j && j.routes && j.routes.length) return j.routes[0];
  } catch(e) { console.error('route error', e); }
  return null;
}

function showRoute(foundRoute, snapped){
  if(destMarker) destMarker.remove();
  if(routeLayer) routeLayer.remove();

  destMarker = L.marker([snapped.lat, snapped.lon], { title:'Destination' }).addTo(map);
  destMarker._icon && destMarker._icon.classList.add('drop-pin');

  const coords = foundRoute.geometry.coordinates.map(c => [c[1], c[0]]);
  routeLayer = L.polyline(coords, { color:'#ff8833', weight:5, opacity:0.95 }).addTo(map);

  // fit bounds
  const bounds = L.latLngBounds([[userCoords.lat, userCoords.lon], [snapped.lat, snapped.lon]]);
  map.fitBounds(bounds.pad(0.4), { animate:true, duration:0.9 });

  const distKm = (foundRoute.distance / 1000);
  const mins = Math.round(foundRoute.duration / 60);
  const tripType = tripTypeSelect.value;

  const displayKm = tripType === 'return' ? (distKm * 2).toFixed(2) : distKm.toFixed(2);
  const displayMins = tripType === 'return' ? Math.round(mins * 2) : mins;

  routeInfo.textContent = `${tripType === 'return' ? 'Return trip' : 'One way'}: ${displayKm} km, approx ${displayMins} min`;
  lastFoundRoute = foundRoute;
  snappedDest = snapped;
}

// --- deep link builder (app + web fallback) ---
function deepAndWebUrl(app, from, to){
  const appleDeep = `maps://?saddr=${from.lat},${from.lon}&daddr=${to.lat},${to.lon}`;
  const appleWeb  = `https://maps.apple.com/?saddr=${from.lat},${from.lon}&daddr=${to.lat},${to.lon}&dirflg=d`;

  const googleDeepIOS = `comgooglemaps://?saddr=${from.lat},${from.lon}&daddr=${to.lat},${to.lon}&travelmode=driving`;
  const googleDeepAndroidIntent = `intent://maps.google.com/maps?f=d&daddr=${to.lat},${to.lon}&saddr=${from.lat},${from.lon}&dirflg=d#Intent;scheme=https;package=com.google.android.apps.maps;end`;
  const googleWeb = `https://www.google.com/maps/dir/?api=1&origin=${from.lat},${from.lon}&destination=${to.lat},${to.lon}&travelmode=driving`;

  const wazeDeep = `waze://?ll=${to.lat},${to.lon}&navigate=yes`;
  const wazeWeb  = `https://waze.com/ul?ll=${to.lat},${to.lon}&navigate=yes`;

  return {
    apple: { deep: appleDeep, web: appleWeb },
    google: { deep_ios: googleDeepIOS, deep_android_intent: googleDeepAndroidIntent, web: googleWeb },
    waze: { deep: wazeDeep, web: wazeWeb }
  }[app];
}

function openMaps(appChoice, from, to){
  const urls = deepAndWebUrl(appChoice, from, to);
  const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
  const isAndroid = /Android/i.test(navigator.userAgent);
  const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

  if(!isMobile){
    // Desktop: open web fallback
    if(appChoice === 'google') window.open(urls.web, '_blank');
    else if(appChoice === 'waze') window.open(urls.web, '_blank');
    else window.open(urls.web, '_blank');
    return;
  }

  let deepUrl = urls.web;
  if(appChoice === 'apple'){
    deepUrl = isIOS ? urls.deep : urls.web;
  } else if(appChoice === 'google'){
    deepUrl = isAndroid ? urls.deep_android_intent : urls.deep_ios;
  } else if(appChoice === 'waze'){
    deepUrl = urls.deep;
  }

  try {
    window.location.href = deepUrl;
  } catch(e){
    // fallback
    if(appChoice === 'google') window.location.href = urls.web;
    else if(appChoice === 'waze') window.location.href = urls.web;
    else window.location.href = urls.web;
    return;
  }

  // fallback: if still visible after 1s, open web
  setTimeout(() => {
    if (!document.hidden) {
      if (appChoice === 'google') window.location.href = urls.web;
      else if (appChoice === 'waze') window.location.href = urls.web;
      else window.location.href = urls.web;
    }
  }, 1000);
}

// helper tolerance checks
function withinTolerance(target, actual){
  const low = target * (1 - TOLERANCE);
  const high = target * (1 + TOLERANCE);
  return actual >= low && actual <= high;
}

// --- main pick logic with smart time radius search ---
pickBtn.addEventListener('click', async () => {
  if(!userCoords){ setStatus('Waiting for location.'); return; }
  pickBtn.disabled = true; openMapsBtn.disabled = true;
  setStatus('Searching for a route...');
  setProgress('Starting search...');
  setAttempts('');
  routeInfo.textContent = 'Searching...';
  monkey.style.transform = 'translateY(-6px) scale(1.08)';

  const mode = modeSelect.value; // 'distance' or 'time'
  const tripType = tripTypeSelect.value; // 'oneway' or 'return'
  const isReturn = tripType === 'return';
  const distanceOneWayTargetKm = Math.max(0.1, parseFloat(kmInput.value) || 5);
  const timeTotalMin = Math.max(5, parseFloat(timeInput.value) || 20);

  // time mode => determine one-way target minutes
  let targetOneWayMin = null;
  if(mode === 'time'){
    targetOneWayMin = isReturn ? (timeTotalMin / 2) : timeTotalMin;
  }

  // base radius guess in meters: use speed * time
  // We'll try highway speed first (100 km/h), then normal (60 km/h) if needed.
  const highwaySpeed = HIGHWAY_SPEED;
  const normalSpeed = NORMAL_SPEED;

  // candidate search loop parameters
  let foundRoute = null;
  let foundSnapped = null;

  // If distance mode: simpler randomized attempts, but still iterative with radius envelope.
  if(mode === 'distance'){
    const targetMeters = distanceOneWayTargetKm * 1000;
    const maxRadius = Math.max(2000, targetMeters * 1.6); // envelope
    let tries = 0;
    while(tries < MAX_TRIES && !foundRoute){
      tries++;
      setAttempts(`Attempt ${tries}/${MAX_TRIES}`);
      // radius choose: bias around targetMeters with jitter
      const radius = Math.min(maxRadius, Math.max(500, targetMeters * (0.6 + Math.random() * 1.4)));
      setProgress(`Trying ${ (radius/1000).toFixed(1) } km radius (distance mode) ‚Äî attempt ${tries}`);
      const cand = randomCoordinate(userCoords.lat, userCoords.lon, radius);
      const snapped = await snapToRoad(cand.lon, cand.lat);
      if(!snapped) { await new Promise(r=>setTimeout(r,80)); continue; }
      if(!isSameIsland(userCoords.lat, snapped.lat)) { await new Promise(r=>setTimeout(r,80)); continue; }
      const route = await getRoute(userCoords, snapped);
      if(!route) { await new Promise(r=>setTimeout(r,80)); continue; }
      const routeKm = route.distance / 1000;
      if(withinTolerance(distanceOneWayTargetKm, routeKm)){
        foundRoute = route;
        foundSnapped = snapped;
        break;
      }
      await new Promise(r=>setTimeout(r, 120 + Math.random()*120));
    }
  } else {
    // TIME MODE: iterative radius adjustments. Start with highway speed estimate.
    // compute initial radius meters from speed and targetOneWayMin
    let attempt = 0;
    let usingSpeed = highwaySpeed;
    let attemptsAtThisSpeed = 0;
    let radius = Math.max(1000, (usingSpeed * (targetOneWayMin / 60)) * 1000);
    // clamp radius
    const MAX_RADIUS = 150000; // 150 km cap
    const MIN_RADIUS = 800; // 0.8 km
    while(attempt < MAX_TRIES && !foundRoute){
      attempt++;
      attemptsAtThisSpeed++;
      setAttempts(`Attempt ${attempt}/${MAX_TRIES}`);
      // Jitter radius a bit to explore nearby
      const jitterFactor = 0.7 + Math.random() * 0.6; // 0.7 - 1.3
      const trialRadius = Math.min(MAX_RADIUS, Math.max(MIN_RADIUS, radius * jitterFactor));
      setProgress(`Trying ${ (trialRadius/1000).toFixed(1) } km radius (attempt ${attempt}) ‚Äî using ${usingSpeed === highwaySpeed ? 'highway' : 'normal'} speed`);
      const cand = randomCoordinate(userCoords.lat, userCoords.lon, trialRadius);
      const snapped = await snapToRoad(cand.lon, cand.lat);
      if(!snapped) { await new Promise(r=>setTimeout(r,80)); continue; }
      if(!isSameIsland(userCoords.lat, snapped.lat)) { await new Promise(r=>setTimeout(r,80)); continue; }
      const route = await getRoute(userCoords, snapped);
      if(!route) { await new Promise(r=>setTimeout(r,80)); continue; }

      const routeMin = route.duration / 60; // one-way minutes
      // check within tolerance
      if(withinTolerance(targetOneWayMin, routeMin)){
        foundRoute = route;
        foundSnapped = snapped;
        break;
      }

      // adjust radius intelligently:
      // If routeMin < targetOneWayMin => need larger radius (route too short) => increase radius
      // If routeMin > targetOneWayMin => need smaller radius (route too long) => decrease radius
      const ratio = targetOneWayMin / Math.max(0.1, routeMin);
      // Soft adjust radius by geometric mean factor but cap changes
      const factor = Math.min(2, Math.max(0.5, 0.9 * ratio + 0.1));
      radius = Math.min(MAX_RADIUS, Math.max(MIN_RADIUS, radius * factor));

      // If we've tried many times using highway speed without success, switch to normal speed to consider twisty/slow roads
      if(attemptsAtThisSpeed >= 8 && usingSpeed === highwaySpeed){
        usingSpeed = normalSpeed;
        attemptsAtThisSpeed = 0;
        // recompute radius from new speed baseline
        radius = Math.max(MIN_RADIUS, Math.min(MAX_RADIUS, (usingSpeed * (targetOneWayMin / 60)) * 1000));
      }

      // slight delay
      await new Promise(r=>setTimeout(r, 140 + Math.random()*180));
    } // end time-mode loop
  } // end else time mode

  // finalize
  if(!foundRoute){
    setStatus('No suitable route found. Try increasing time/distance or allow a wider tolerance.');
    setProgress('Search finished: no match.');
    routeInfo.textContent = 'No route found';
    pickBtn.disabled = false; monkey.style.transform = '';
    return;
  }

  // success
  showRoute(foundRoute, foundSnapped);
  setStatus('Found a route!');
  setProgress('Done.');
  setAttempts('');
  openMapsBtn.disabled = false;
  pickBtn.disabled = false;
  monkey.style.transform = '';
});

// open maps
function deepAndWebUrl(app, from, to){
  const appleDeep = `maps://?saddr=${from.lat},${from.lon}&daddr=${to.lat},${to.lon}`;
  const appleWeb  = `https://maps.apple.com/?saddr=${from.lat},${from.lon}&daddr=${to.lat},${to.lon}&dirflg=d`;

  const googleDeepIOS = `comgooglemaps://?saddr=${from.lat},${from.lon}&daddr=${to.lat},${to.lon}&travelmode=driving`;
  const googleDeepAndroidIntent = `intent://maps.google.com/maps?f=d&daddr=${to.lat},${to.lon}&saddr=${from.lat},${from.lon}&dirflg=d#Intent;scheme=https;package=com.google.android.apps.maps;end`;
  const googleWeb = `https://www.google.com/maps/dir/?api=1&origin=${from.lat},${from.lon}&destination=${to.lat},${to.lon}&travelmode=driving`;

  const wazeDeep = `waze://?ll=${to.lat},${to.lon}&navigate=yes`;
  const wazeWeb  = `https://waze.com/ul?ll=${to.lat},${to.lon}&navigate=yes`;

  return {
    apple: { deep: appleDeep, web: appleWeb },
    google: { deep_ios: googleDeepIOS, deep_android_intent: googleDeepAndroidIntent, web: googleWeb },
    waze: { deep: wazeDeep, web: wazeWeb }
  }[app];
}

function openMaps(appChoice, from, to){
  const urls = deepAndWebUrl(appChoice, from, to);
  const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
  const isAndroid = /Android/i.test(navigator.userAgent);
  const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

  if(!isMobile){
    // desktop fallback -> open web
    if(appChoice === 'google') window.open(urls.web, '_blank');
    else if(appChoice === 'waze') window.open(urls.web, '_blank');
    else window.open(urls.web, '_blank');
    return;
  }

  let deepUrl = urls.web;
  if(appChoice === 'apple'){
    deepUrl = isIOS ? urls.deep : urls.web;
  } else if(appChoice === 'google'){
    deepUrl = isAndroid ? urls.deep_android_intent : urls.deep_ios;
  } else if(appChoice === 'waze'){
    deepUrl = urls.deep;
  }

  try { window.location.href = deepUrl; } catch(e) {
    if(appChoice === 'google') window.location.href = urls.web;
    else if(appChoice === 'waze') window.location.href = urls.web;
    else window.location.href = urls.web;
    return;
  }
  setTimeout(()=> {
    if(!document.hidden) {
      if(appChoice === 'google') window.location.href = urls.web;
      else if(appChoice === 'waze') window.location.href = urls.web;
      else window.location.href = urls.web;
    }
  }, 1000);
}

openMapsBtn.addEventListener('click', () => {
  if(!userCoords || !snappedDest) return;
  openMaps(mapAppSelect.value, userCoords, snappedDest);
});

clearBtn.addEventListener('click', () => {
  if(destMarker) destMarker.remove();
  if(routeLayer) routeLayer.remove();
  destMarker = null; routeLayer = null; snappedDest = null; lastFoundRoute = null;
  routeInfo.textContent = 'No route selected'; setStatus(''); setProgress('Idle.'); setAttempts(''); openMapsBtn.disabled = true;
});

// cleanup splash
setTimeout(()=> hideSplash(), 7000);

// monkey wiggle
document.querySelector('.mascot-bubble').addEventListener('click',()=>{
  monkey.style.transition = 'transform 220ms';
  monkey.style.transform = 'translateY(-10px) rotate(-8deg)';
  setTimeout(()=> monkey.style.transform = '', 420);
});
</script>

</body>
</html>
