<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<title>Tiki Tour</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

<style>
  :root{
    --bg:#fff; --card:#f8f8f8; --text:#111; --muted:#666;
    --accent:#ff8833; --shadow: 0 8px 24px rgba(10,10,10,0.08);
    --glass: rgba(255,255,255,0.6);
  }
  @media (prefers-color-scheme: dark) {
    :root{
      --bg: #081018; --card: rgba(12,18,24,0.7); --text:#e9f5ef; --muted:#9fb3a6;
      --accent:#ffb06b; --shadow: 0 10px 30px rgba(0,0,0,0.6);
    }
  }
  html,body{height:100%;margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial; background: linear-gradient(180deg, rgba(255,241,224,0.3), transparent 40%), var(--bg); color:var(--text); -webkit-font-smoothing:antialiased;}
  @media (prefers-color-scheme: light) { body{background: linear-gradient(180deg, #fff8f0, #f7fbf9 60%), var(--bg);} }

  /* splash */
  #splash { position:fixed; inset:0; z-index:9999; display:flex; align-items:center; justify-content:center; background: linear-gradient(135deg, rgba(3,91,70,0.95), rgba(19,53,57,0.95)); color:white; flex-direction:column; gap:18px; -webkit-backdrop-filter: blur(6px); backdrop-filter: blur(6px); }
  .tiki { width:86px;height:86px;border-radius:18px;background:linear-gradient(180deg,#ffe1b9,#ffd59a);display:flex;align-items:center;justify-content:center;box-shadow:0 12px 40px rgba(0,0,0,0.35); transform: rotate(-6deg); }
  .tiki-emoji{font-size:46px;transform:translateY(6px);}
  .coconut { width:46px;height:46px;border-radius:50%;border:4px solid rgba(255,255,255,0.12);display:flex;align-items:center;justify-content:center; animation:coconutSpin 1500ms linear infinite; }
  @keyframes coconutSpin{from{transform:rotate(0deg);}to{transform:rotate(360deg);} }

  /* app shell */
  #app { max-width:1000px;margin:12vh auto 48px;padding:12px;box-sizing:border-box; }
  .card { background:var(--card); border-radius:14px; box-shadow:var(--shadow); overflow:hidden; padding:0; -webkit-backdrop-filter: blur(6px); }
  #map { width:100%; height:64vh; min-height:420px; display:block; border-radius:12px 12px 0 0; }

  .controls { display:flex; gap:10px; padding:14px; align-items:center; flex-wrap:wrap;}
  .input { display:flex; gap:8px; align-items:center;}
  label.small { font-size:13px; color:var(--muted); margin-right:6px; }
  input[type="number"], select { width:120px; padding:10px 12px; border-radius:10px; border:1px solid rgba(0,0,0,0.06); background:transparent; color:var(--text); font-size:15px; outline:none;}
  @media (prefers-color-scheme: dark) { input[type="number"], select { border:1px solid rgba(255,255,255,0.04); } }

  .btn { padding:10px 14px; font-weight:700; border-radius:12px; border:none; cursor:pointer; font-size:15px; box-shadow:0 6px 18px rgba(0,0,0,0.12); background: linear-gradient(180deg,var(--accent), color-mix(in srgb, var(--accent) 85%, black 8%)); color:#062014; display:inline-flex; align-items:center; gap:8px; transition: transform 180ms ease, box-shadow 180ms ease; }
  .btn.ghost { background:transparent; color:var(--text); border:1px solid rgba(0,0,0,0.06); }
  .btn:active { transform: translateY(2px); box-shadow: 0 4px 12px rgba(0,0,0,0.12); }

  .stats { padding:8px 14px 18px 14px; display:flex; gap:12px; align-items:center; flex-wrap:wrap;}
  .pill { background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02)); padding:8px 12px; border-radius:999px; font-weight:700; color:var(--text); }

  .mascot { position: fixed; right:14px; bottom:18vh; z-index:900; display:flex; align-items:center; gap:10px; pointer-events:none; }
  .monkey { font-size:38px; transform-origin:center; display:inline-block; animation:monkeyDance 1600ms ease-in-out infinite; filter: drop-shadow(0 8px 18px rgba(0,0,0,0.25)); }
  .mascot-bubble { background:var(--glass); padding:8px 10px; border-radius:999px; font-weight:700; color:var(--text); font-size:14px; box-shadow:0 6px 18px rgba(0,0,0,0.08); pointer-events:none; }
  @keyframes monkeyDance { 0%{transform:translateY(0) rotate(-6deg) scale(1);} 25%{transform:translateY(-6px) rotate(6deg) scale(1.06);} 50%{transform:translateY(0px) rotate(-4deg) scale(1);} 75%{transform:translateY(-4px) rotate(8deg) scale(1.03);} 100%{transform:translateY(0) rotate(-6deg) scale(1);} }

  .drop-pin { animation: dropPin 540ms cubic-bezier(.2,.9,.2,1) both; }
  @keyframes dropPin { 0%{transform:translateY(-200px) scale(0.8); opacity:0;} 60%{transform:translateY(16px) scale(1.05); opacity:1;} 100%{transform:translateY(0) scale(1);} }
  .hidden{display:none;}
  @media (max-width:520px) { .controls{padding:12px;gap:8px;} #map{height:65vh;min-height:360px;} .mascot{right:10px;bottom:22vh;} body{margin-bottom:48px;} }
</style>
</head>
<body>

<!-- Splash -->
<div id="splash" aria-hidden="false">
  <div class="tiki"><div class="tiki-emoji">üå∫</div></div>
  <div class="splash-title">
    <div style="display:flex;flex-direction:column;line-height:1">
      <div style="font-size:20px;font-weight:900">Tiki Tour</div>
      <div style="font-size:12px;opacity:0.95">Find a random road. Take a little adventure.</div>
    </div>
  </div>
  <div class="coconut center" style="margin-top:8px"><div style="font-size:20px">ü••</div></div>
</div>

<div id="app" class="card" style="max-width:880px;margin:auto">

  <div id="map"></div>

  <div class="controls">
    <!-- Mode Option A: By Distance / By Time -->
    <div class="input">
      <label class="small">Mode</label>
      <select id="modeSelect" aria-label="Mode: By Distance or By Time">
        <option value="distance">By Distance</option>
        <option value="time">By Time</option>
      </select>
    </div>

    <div class="input">
      <label class="small" for="kmInput">Distance km (one-way target)</label>
      <input id="kmInput" type="number" step="0.1" min="0.1" value="30" />
    </div>

    <div class="input">
      <label class="small" for="timeInput">Time min (total)</label>
      <input id="timeInput" type="number" step="1" min="5" value="60" />
    </div>

    <div class="input">
      <label class="small" for="tripType">Trip</label>
      <select id="tripType">
        <option value="oneway">One Way</option>
        <option value="return">Return Trip</option>
      </select>
    </div>

    <div class="input">
      <label class="small" for="mapApp">Open with</label>
      <select id="mapApp">
        <option value="apple">Apple Maps</option>
        <option value="google">Google Maps</option>
        <option value="waze">Waze</option>
      </select>
    </div>

    <button id="pickBtn" class="btn" title="Pick a random drivable road near you">üéØ Pick Random Road</button>
    <button id="openMapsBtn" class="btn ghost" disabled>üß≠ Open</button>
    <button id="clearBtn" class="btn ghost">üßπ Clear</button>

    <div id="status" style="margin-left:auto;color:var(--muted);font-size:14px">Waiting for location.</div>
  </div>

  <div class="stats">
    <div id="routeInfo" class="pill">No route selected</div>
    <div style="color:var(--muted);font-size:13px">Tip: distance input is one-way target. If "Return Trip" is chosen we aim to double the time/distance unless using time mode when we split the total.</div>
  </div>

</div>

<div class="mascot" aria-hidden="true">
  <div class="mascot-bubble">Ready for a Tiki hop?</div>
  <div class="monkey" id="monkeyEmoji">üêí</div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
/*
  Full file implementing:
  - Mode: By Distance / By Time (Option A)
  - Return trip support (splits time by two when searching by time)
  - Mobile deep-links to Apple / Google / Waze with web fallback
  - Avoids selecting points across NZ islands (basic lat filter)
  - Uses OSRM nearest & route endpoints
*/

const splash = document.getElementById('splash');
const statusEl = document.getElementById('status');
const kmInput = document.getElementById('kmInput');
const timeInput = document.getElementById('timeInput');
const modeSelect = document.getElementById('modeSelect');
const tripTypeSelect = document.getElementById('tripType');
const mapAppSelect = document.getElementById('mapApp');
const pickBtn = document.getElementById('pickBtn');
const openMapsBtn = document.getElementById('openMapsBtn');
const clearBtn = document.getElementById('clearBtn');
const routeInfo = document.getElementById('routeInfo');
const monkey = document.getElementById('monkeyEmoji');

let userCoords = null;
let userMarker = null;
let destMarker = null;
let routeLayer = null;
let snappedDest = null;
let lastFoundRoute = null;

const map = L.map('map', { zoomControl: true }).setView([0,0], 2);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19, attribution: '¬© OpenStreetMap contributors'
}).addTo(map);

function hideSplash(){ if(!splash) return; splash.style.opacity='0'; splash.style.transform='scale(0.98)'; setTimeout(()=> { if(splash) splash.remove(); }, 520); }
function setStatus(t){ statusEl.textContent = t || ''; }

// Attempt to get location once then keep updates small
function enableLocation(){
  if (!navigator.geolocation) { setStatus('Location not supported by browser.'); return; }
  setStatus('Locating you.');
  navigator.geolocation.getCurrentPosition(pos => {
    userCoords = { lat: pos.coords.latitude, lon: pos.coords.longitude };
    setStatus('');
    if (userMarker) userMarker.remove();
    userMarker = L.marker([userCoords.lat, userCoords.lon], { title: 'You' }).addTo(map);
    map.setView([userCoords.lat, userCoords.lon], 13);
    hideSplash();
  }, err => {
    console.error(err);
    setStatus('Allow location in browser and reload.');
  }, { enableHighAccuracy:true, maximumAge:15000, timeout:12000 });
}
enableLocation();

setInterval(() => {
  if (!document.hidden && navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(pos => {
      userCoords = { lat: pos.coords.latitude, lon: pos.coords.longitude };
      if (userMarker) userMarker.setLatLng([userCoords.lat, userCoords.lon]);
    }, () => {}, { enableHighAccuracy:true, maximumAge:20000 });
  }
}, 8000);

// Small UI behavior: when mode changes disable irrelevant input
function updateModeUI() {
  if (modeSelect.value === 'distance') {
    kmInput.disabled = false;
    timeInput.disabled = true;
    timeInput.style.opacity = '0.6';
    kmInput.style.opacity = '1';
  } else {
    kmInput.disabled = true;
    timeInput.disabled = false;
    timeInput.style.opacity = '1';
    kmInput.style.opacity = '0.6';
  }
}
modeSelect.addEventListener('change', updateModeUI);
updateModeUI();

// --- island check (rough) to avoid picking a point in other island ---
// These are rough lat boundaries: north island roughly above -41.6 lat
const NORTH_ISLAND_MIN_LAT = -41.6;
function isSameIsland(latA, latB) {
  const aNorth = latA > NORTH_ISLAND_MIN_LAT;
  const bNorth = latB > NORTH_ISLAND_MIN_LAT;
  return (aNorth && bNorth) || (!aNorth && !bNorth);
}

// --- geospatial helpers ---
function randomCoordinate(centerLat, centerLon, maxMeters) {
  const R = 6371000;
  const r = Math.sqrt(Math.random()) * maxMeters;
  const bearing = Math.random() * Math.PI * 2;
  const lat1 = centerLat * Math.PI / 180;
  const lon1 = centerLon * Math.PI / 180;
  const lat2 = Math.asin(Math.sin(lat1) * Math.cos(r / R) + Math.cos(lat1) * Math.sin(r / R) * Math.cos(bearing));
  const lon2 = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(r / R) * Math.cos(lat1), Math.cos(r / R) - Math.sin(lat1) * Math.sin(lat2));
  return { lat: lat2 * 180 / Math.PI, lon: lon2 * 180 / Math.PI };
}

async function snapToRoad(lon, lat) {
  try {
    const url = `https://router.project-osrm.org/nearest/v1/driving/${lon},${lat}?number=1`;
    const res = await fetch(url);
    if (!res.ok) return null;
    const j = await res.json();
    if (j && j.waypoints && j.waypoints.length) {
      const wp = j.waypoints[0];
      return { lat: wp.location[1], lon: wp.location[0] };
    }
  } catch (e) { console.error('snap error', e); }
  return null;
}

async function getRoute(user, dest) {
  try {
    const coords = `${user.lon},${user.lat};${dest.lon},${dest.lat}`;
    const url = `https://router.project-osrm.org/route/v1/driving/${coords}?overview=full&geometries=geojson&steps=false`;
    const res = await fetch(url);
    if (!res.ok) return null;
    const j = await res.json();
    if (j && j.routes && j.routes.length) return j.routes[0];
  } catch (e) { console.error('route error', e); }
  return null;
}

// show route on map
function showRoute(foundRoute, snapped) {
  if (destMarker) destMarker.remove();
  if (routeLayer) routeLayer.remove();

  destMarker = L.marker([snapped.lat, snapped.lon], { title: 'Destination' }).addTo(map);
  destMarker._icon && destMarker._icon.classList.add('drop-pin');

  const coords = foundRoute.geometry.coordinates.map(c => [c[1], c[0]]);
  routeLayer = L.polyline(coords, { color: '#ff8833', weight: 5, opacity: 0.95 }).addTo(map);

  // fit bounds
  const bounds = L.latLngBounds([[userCoords.lat, userCoords.lon], [snapped.lat, snapped.lon]]);
  map.fitBounds(bounds.pad(0.4), { animate: true, duration: 0.9 });

  const distKm = (foundRoute.distance / 1000);
  const mins = Math.round(foundRoute.duration / 60);
  const tripType = tripTypeSelect.value;

  // compute displayed totals:
  let displayKm, displayMins;
  if (modeSelect.value === 'distance') {
    displayKm = tripType === 'return' ? (distKm * 2).toFixed(2) : distKm.toFixed(2);
    displayMins = tripType === 'return' ? Math.round(mins * 2) : mins;
  } else {
    // mode=time -> route.duration is one-way candidate
    displayKm = tripType === 'return' ? (distKm * 2).toFixed(2) : distKm.toFixed(2);
    displayMins = tripType === 'return' ? Math.round(mins * 2) : mins;
  }

  routeInfo.textContent = `${tripType === 'return' ? 'Return trip' : 'One way'}: ${displayKm} km, approx ${displayMins} min`;
  lastFoundRoute = foundRoute;
  snappedDest = snapped;
}

// --- Deep-link URLs (app) + web fallback URLs ---
// build app-specific deep links and web fallbacks
function deepAndWebUrl(app, from, to) {
  // from {lat,lon}, to {lat,lon}
  const appleDeep = `maps://?saddr=${from.lat},${from.lon}&daddr=${to.lat},${to.lon}`;
  const appleWeb  = `https://maps.apple.com/?saddr=${from.lat},${from.lon}&daddr=${to.lat},${to.lon}&dirflg=d`;

  const googleDeepIOS = `comgooglemaps://?saddr=${from.lat},${from.lon}&daddr=${to.lat},${to.lon}&travelmode=driving`;
  const googleDeepAndroidIntent = `intent://maps.google.com/maps?f=d&daddr=${to.lat},${to.lon}&saddr=${from.lat},${from.lon}&dirflg=d#Intent;scheme=https;package=com.google.android.apps.maps;end`;
  const googleWeb = `https://www.google.com/maps/dir/?api=1&origin=${from.lat},${from.lon}&destination=${to.lat},${to.lon}&travelmode=driving`;

  const wazeDeep = `waze://?ll=${to.lat},${to.lon}&navigate=yes`;
  const wazeWeb  = `https://waze.com/ul?ll=${to.lat},${to.lon}&navigate=yes`;

  return {
    apple: { deep: appleDeep, web: appleWeb },
    google: { deep_ios: googleDeepIOS, deep_android_intent: googleDeepAndroidIntent, web: googleWeb },
    waze: { deep: wazeDeep, web: wazeWeb }
  }[app];
}

// open in app if mobile, otherwise open web
function openMaps(appChoice, from, to) {
  const urls = deepAndWebUrl(appChoice, from, to);

  const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
  const isAndroid = /Android/i.test(navigator.userAgent);
  const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

  if (!isMobile) {
    // Desktop: open web
    if (appChoice === 'google') window.open(urls.web, '_blank');
    else if (appChoice === 'waze') window.open(urls.web, '_blank');
    else window.open(urls.web, '_blank'); // apple web works cross-platform
    return;
  }

  // Mobile attempt: try deep link first, fallback to web after short delay if page still visible
  let triedDeep = false;
  let deepUrl = urls.web;
  if (appChoice === 'apple') {
    if (isIOS) deepUrl = urls.deep;
    else deepUrl = urls.web; // Apple Maps deep link generally only works on iOS
  } else if (appChoice === 'google') {
    if (isIOS) deepUrl = urls.deep_ios;
    if (isAndroid) deepUrl = urls.deep_android_intent; // intent better on Android
  } else if (appChoice === 'waze') {
    deepUrl = urls.deep;
  }

  // Try deep link. Use visibility API to detect if app opened (page hidden). If not hidden after timeout, open web URL.
  triedDeep = true;
  const start = Date.now();
  // attempt navigation
  try {
    window.location.href = deepUrl;
  } catch (e) {
    // if setting href failed, fallback to web
    if (appChoice === 'google') window.location.href = urls.web;
    else if (appChoice === 'waze') window.location.href = urls.web;
    else window.location.href = urls.web;
    return;
  }

  // fallback trigger: if user didn't leave page in 1 second, open web url
  const fallback = () => {
    if (!document.hidden) {
      // still visible: deep link probably did not open the app
      if (appChoice === 'google') {
        // if android deep intent didn't open, fall back to web
        window.location.href = urls.web;
      } else if (appChoice === 'waze') {
        window.location.href = urls.web;
      } else {
        window.location.href = urls.web;
      }
    }
  };
  setTimeout(fallback, 1000);
}

// --- Main pick logic ---
// Tolerances: +-10%
const TOLERANCE = 0.10;

// Attempt count
const MAX_TRIES = 40;

// Helper: distance km tolerance check
function withinTolerance(target, actual) {
  const low = target * (1 - TOLERANCE);
  const high = target * (1 + TOLERANCE);
  return actual >= low && actual <= high;
}

pickBtn.addEventListener('click', async () => {
  if (!userCoords) { setStatus('Waiting for location.'); return; }
  pickBtn.disabled = true;
  openMapsBtn.disabled = true;
  setStatus('Searching for a route...');
  routeInfo.textContent = 'Searching...';
  monkey.style.transform = 'translateY(-6px) scale(1.08)';

  const mode = modeSelect.value; // 'distance' or 'time'
  const tripType = tripTypeSelect.value; // 'oneway' or 'return'
  const kmTargetInput = Math.max(0.1, parseFloat(kmInput.value) || 5);
  const timeTotalInput = Math.max(5, parseFloat(timeInput.value) || 30); // total minutes if time mode

  // interpret targets:
  // distance mode -> kmTargetInput is one-way target (user wanted one-way)
  // time mode -> timeTotalInput is total (if return selected we split in half per leg)
  const isReturn = tripType === 'return';

  // compute one-way targets used for matching:
  let targetOneWayKm;
  let targetOneWayMin;

  if (mode === 'distance') {
    targetOneWayKm = kmTargetInput;
    // no direct time target in distance mode; we'll accept any time, display ETA later
  } else {
    if (isReturn) targetOneWayMin = (timeTotalInput / 2);
    else targetOneWayMin = timeTotalInput;
  }

  const maxMeters = Math.max(200, (mode === 'distance' ? kmTargetInput * 1000 : 50000));
  let foundRoute = null;
  let foundSnapped = null;

  for (let i=0; i<MAX_TRIES; i++) {
    setStatus(`Trying point ${i+1} of ${MAX_TRIES}...`);
    // pick random candidate at radius up to maxMeters (we vary radius a bit to diversify)
    const radius = maxMeters * (0.4 + Math.random() * 0.6);
    const cand = randomCoordinate(userCoords.lat, userCoords.lon, radius);
    const snapped = await snapToRoad(cand.lon, cand.lat);
    if (!snapped) continue;

    // island check (avoid choosing across islands)
    if (!isSameIsland(userCoords.lat, snapped.lat)) continue;

    // compute approximate straight-line distance to avoid tiny picks
    const dx = (snapped.lat - userCoords.lat);
    const dy = (snapped.lon - userCoords.lon);
    const approxDist = Math.sqrt(dx*dx + dy*dy) * 111000;
    if (approxDist < 30) continue;

    const route = await getRoute(userCoords, snapped);
    if (!route) continue;

    // route.distance (meters) route.duration (seconds) are one-way
    const routeKm = route.distance / 1000;
    const routeMin = route.duration / 60;

    // Requirements
    let ok = false;
    if (mode === 'distance') {
      // aim for targetOneWayKm within tolerance
      if (withinTolerance(targetOneWayKm, routeKm)) ok = true;
      // If return selected, routeKm doubled should be within tolerance of total target? we used one-way input so ok this way.
      // Also allow slightly longer/shorter routes if user set large maxMeters
    } else {
      // time mode: routeMin should be approx targetOneWayMin within tolerance
      if (withinTolerance(targetOneWayMin, routeMin)) ok = true;
    }

    // Also enforce upper time limit: if user gave a total time and route would exceed (for safety)
    // We'll calculate totalDuration depending on tripType
    let totalDurationSecs = route.duration;
    if (isReturn) totalDurationSecs *= 2;

    const userTimeLimitSecs = (mode === 'time') ? (timeTotalInput * 60) : (60 * 60 * 6); // if not time mode, allow up to 6 hours total
    if (totalDurationSecs > userTimeLimitSecs * (1 + 0.25)) {
      // route would exceed time limit by big margin, skip
      ok = false;
    }

    if (ok) {
      foundRoute = route;
      foundSnapped = snapped;
      break;
    }

    // small delay to avoid hammering
    await new Promise(r => setTimeout(r, 120 + Math.random()*200));
  }

  if (!foundRoute) {
    setStatus('Could not find a suitable drivable road within that search. Try increasing time/distance or try again.');
    routeInfo.textContent = 'No route found';
    pickBtn.disabled = false;
    monkey.style.transform = '';
    return;
  }

  // Found route: show on map
  showRoute(foundRoute, foundSnapped);
  setStatus('');
  openMapsBtn.disabled = false;
  pickBtn.disabled = false;
  monkey.style.transform = '';
});

// Open maps button: use deep link on mobile with fallback
openMapsBtn.addEventListener('click', () => {
  if (!userCoords || !snappedDest) return;
  openMaps(mapAppSelect.value, userCoords, snappedDest);
});

// Clear
clearBtn.addEventListener('click', () => {
  if (destMarker) destMarker.remove();
  if (routeLayer) routeLayer.remove();
  destMarker = null; routeLayer = null; snappedDest = null; lastFoundRoute = null;
  routeInfo.textContent = 'No route selected';
  setStatus('');
  openMapsBtn.disabled = true;
});

// UX: remove splash after some time if permission denied
setTimeout(() => { if (splash) hideSplash(); }, 7000);

// quick monkey wiggle
document.querySelector('.mascot-bubble').addEventListener('click', () => {
  monkey.style.transition = 'transform 220ms';
  monkey.style.transform = 'translateY(-10px) rotate(-8deg)';
  setTimeout(()=> monkey.style.transform = '', 420);
});
</script>

</body>
</html>
